use kernel::hil;
use core::cell::Cell;
use core::mem;
// Automatically generated by tm4c129x_codegen.py
use kernel::common::VolatileCell;
use sysctl;

#[repr(C)]
struct Registers {
    cfg: VolatileCell<u32>,
    tamr: VolatileCell<u32>,
    tbmr: VolatileCell<u32>,
    ctl: VolatileCell<u32>,
    sync: VolatileCell<u32>,
    _reserved0: [u32; 1],
    imr: VolatileCell<u32>,
    ris: VolatileCell<u32>,
    mis: VolatileCell<u32>,
    icr: VolatileCell<u32>,
    tailr: VolatileCell<u32>,
    tbilr: VolatileCell<u32>,
    tamatchr: VolatileCell<u32>,
    tbmatchr: VolatileCell<u32>,
    tapr: VolatileCell<u32>,
    tbpr: VolatileCell<u32>,
    tapmr: VolatileCell<u32>,
    tbpmr: VolatileCell<u32>,
    tar: VolatileCell<u32>,
    tbr: VolatileCell<u32>,
    tav: VolatileCell<u32>,
    tbv: VolatileCell<u32>,
    rtcpd: VolatileCell<u32>,
    taps: VolatileCell<u32>,
    tbps: VolatileCell<u32>,
    _reserved1: [u32; 2],
    dmaev: VolatileCell<u32>,
    adcev: VolatileCell<u32>,
    _reserved2: [u32; 979],
    pp: VolatileCell<u32>,
    _reserved3: [u32; 1],
    cc: VolatileCell<u32>,
}

const TIMER0_BASE: usize = 0x40030000;

pub static mut TIMER0: AlarmTimer = AlarmTimer::new(TIMER0_BASE,
                                                    sysctl::Clock::TIMER(sysctl::RCGCTIMER::TIMER0));

pub struct AlarmTimer {
    registers: *mut Registers,
    clock: sysctl::Clock,
    client: Cell<Option<&'static hil::time::Client>>,
}

impl AlarmTimer {
    const fn new(base_addr: usize, clock: sysctl::Clock) -> AlarmTimer {
        AlarmTimer {
            registers: base_addr as *mut Registers,
            clock: clock,
            client: Cell::new(None),
        }
    }

    fn disable_interrupts(&self) {
        let regs: &mut Registers = unsafe { mem::transmute(self.registers) };
		regs.tamr.set(regs.tamr.get() | (1 << 12)); // GPTM Timer A Match Interrupt 
		//regs.imr.set(regs.imr.get() & !(1 << 4));
        
    }

    pub fn handle_interrupt(&self) {
        let regs: &mut Registers = unsafe { mem::transmute(self.registers) };
        // check if caused by TAMMIS
        if regs.mis.get() & (1 << 0) != 0 {
            self.disable_interrupts();
            regs.icr.set(regs.icr.get() | (1 << 0)); // clear TAMCINT
            self.client.get().map(|cb| { cb.fired(); });
        }
    }
}

impl hil::Controller for AlarmTimer {
    type Config = &'static hil::time::Client;

    fn configure(&self, client: &'static hil::time::Client) {
        unsafe {
            sysctl::enable_clock(self.clock);
        }
        
        self.client.set(Some(client));
		let regs: &mut Registers = unsafe { mem::transmute(self.registers) };
		
        regs.ctl.set(0x0);
        regs.cfg.set(0x0);
        regs.tamr.set(regs.tamr.get() | 0x11 ); // One-Shot count-up
        regs.imr.set(regs.imr.get() | (1 << 0)); // TAMIM enable
    }
}

impl hil::time::Time for AlarmTimer {
    type Frequency = hil::time::Freq16KHz;

    fn disable(&self) {
        self.disable_interrupts();
    }

    fn is_armed(&self) -> bool {
        let regs: &mut Registers = unsafe { mem::transmute(self.registers) };
        //regs.imr.get() & (1 << 4) != 0 // TAMIM
		regs.tamr.get() & (1 << 12) != 1 // TAMIE
    }
}

impl hil::time::Alarm for AlarmTimer {
    fn now(&self) -> u32 {
        let regs: &mut Registers = unsafe { mem::transmute(self.registers) };
        regs.tar.get()
    }

    fn set_alarm(&self, tics: u32) {
        let regs: &mut Registers = unsafe { mem::transmute(self.registers) };
        //regs.tamatchr.set(tics * (sysctl::get_system_frequency() / 16000));  
        regs.tailr.set(tics * (sysctl::get_system_frequency() / 16000)); 
        regs.tamr.set(regs.tamr.get() & !(1 << 12)); // clear TAMIE              
		regs.ctl.set(regs.ctl.get() | (1 << 0)); // TAEN    
		//regs.imr.set(regs.imr.get() | (1 << 4)); // CC1IE // TAMIE auch deaktivieren?		
    }

    fn get_alarm(&self) -> u32 {
        let regs: &mut Registers = unsafe { mem::transmute(self.registers) };
        regs.tailr.get()
    }
}
